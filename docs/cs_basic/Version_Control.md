# Git版本控制
!!! info
    * 同时执行多个不同的进程并追踪它们的状态
    * 停止或暂停某个进程以及如何使进程在后台运行
    * 改善 shell 及其他工具的工作流的方法

## Git 的数据模型

Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如`维护历史记录`、`支持分支`和`促进协作`。

### 快照

Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。

在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。

快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：

![3](/img/3.png)

这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。

### 历史记录建模：关联快照

线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。

在 Git 中，历史记录是一个由快照组成的有向无环图。

Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。

在 Git 中，这些快照被称为“提交”。类似下图所示：

![4](/img/4.png)

箭头指向了当前提交的父辈。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：

![5](/img/5.png)

Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。

### 数据模型及其伪代码表示
```python
    // 文件就是一组数据
    type blob = array<byte>

    // 一个包含文件和目录的目录
    type tree = map<string, tree | blob>

    // 每个提交都包含一个父辈，元数据和顶层树
    type commit = struct {
        parent: array<commit>
        author: string
        message: string
        snapshot: tree
}
```

### 对象和内存寻址
Git 中的对象可以是 blob、树或提交：
```cpp
    type object = blob | tree | commit
```

Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址。
```python
    objects = map<string, object>

    def store(object):
        id = sha1(object)
        objects[id] = object

    def load(id):
        return objects[id]
```

Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。

例如，上面例子中的树（可以通过 git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d 来进行可视化），看上去是这样的：

```python
    100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt
    040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo

```

树本身会包含一些指向其他内容的指针，例如 baz.txt (blob) 和 foo (树)。如果我们用 git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85，即通过哈希值查看 baz.txt 的内容，会得到以下信息：

```python
    git is wonderful
```

### 引用
所有的快照都可以通过它们的 SHA-1 哈希值来标记,但这太不方便，因为记不住一串 40 位的十六进制字符。

针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。

引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，master 引用通常会指向主分支的最新一次提交。
```python
    references = map<string, string>

    def update_reference(name, id):
        references[name] = id

    def read_reference(name):
        return references[name]

    def load_reference(name_or_id):
        if name_or_id in references:
            return load(references[name_or_id])
        else:
            return load(name_or_id)
```
这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。

有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。

### 仓库

最后，我们可以粗略地给出 Git 仓库的定义了：`对象` 和 `引用`。

在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 git 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。

!!! tip
    当输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。
    
    另一方面，如果希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 5d83f9e 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 git checkout master; git reset --hard 5d83f9e）

## 暂存区

Git 中还包括一个和数据模型完全不相关的概念，它确是创建提交的接口的一部分。

就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。

有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。

Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。

## Git 的命令行接口

### 基础
`git help [command]`: 获取 git 命令的帮助信息

`git init`: 创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下

`git status`: 显示当前的仓库状态

`git add [filename]`: 添加文件到暂存区

`git commit`: 创建一个新的提交

`git log`: 显示历史日志

`git log --all --graph --decorate`: 可视化历史记录（有向无环图）

`git diff [filename]`: 显示与暂存区文件的差异

`git diff [revision] [filename]`: 显示某个文件两个版本之间的差异

`git checkout [revision]`: 更新 HEAD 和目前的分支